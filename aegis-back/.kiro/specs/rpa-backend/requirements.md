# Requirements Document

## Introduction

The AEGIS RPA Backend is a cognitive, intent-driven automation engine that processes natural language instructions and executes desktop tasks through intelligent orchestration of RPA tools. The system acts as a smart assistant capable of multi-app orchestration, translating high-level goals into sequences of low-level desktop actions (mouse clicks, keyboard input, system commands) while providing real-time feedback to the frontend.

## Glossary

- **AEGIS Backend**: The Python FastAPI server responsible for processing task instructions and executing desktop automation
- **Task Instruction**: A natural language string provided by the user describing the desired automation goal
- **RPA Engine**: The core component that executes low-level desktop actions using PyAutoGUI and PyWin32
- **Strategy Module**: The component that determines whether to use coordinate-based or element-based interaction strategies
- **Execution Session**: A single end-to-end automation run from instruction receipt to completion
- **Subtask**: An individual step within an execution session (e.g., "open application", "click button")
- **Action Observer**: The component that verifies action success after each step
- **WebSocket Stream**: The real-time communication channel for sending status updates to the frontend
- **NLP Processor**: The component that parses natural language instructions into structured action sequences
- **ADK Agent**: The Google Agent Development Kit (ADK) Gemini-based agent that serves as the cognitive engine for task interpretation and planning
- **ADK Toolbox**: The collection of custom Python functions (built on pyautogui, win32api) that the ADK agent calls to perform desktop actions
- **Execution Plan**: The multi-step RPA tool-use plan generated by the ADK agent from a natural language instruction
- **Pre-Processing Layer**: The FastAPI component that validates and handles local issues before invoking the ADK agent
- **Plan Cache**: The storage mechanism for reusing previously generated execution plans for identical or similar instructions
- **Window State Command**: A WebSocket message sent to the frontend to control window mode (minimal or normal)

## Requirements

### Requirement 1

**User Story:** As a system architect, I want the backend to utilize a Gemini-based ADK agent as the cognitive engine, so that the system can intelligently interpret natural language instructions and orchestrate complex multi-step automations.

#### Acceptance Criteria

1. WHEN the AEGIS Backend initializes, THEN the AEGIS Backend SHALL instantiate a Google Agent Development Kit (ADK) agent configured with the Gemini model
2. WHEN the ADK Agent is configured, THEN the AEGIS Backend SHALL register a custom Toolbox containing Python functions built on pyautogui and win32api
3. WHEN a task instruction is received, THEN the AEGIS Backend SHALL delegate the interpretation and planning process to the ADK Agent
4. WHEN the ADK Agent generates an execution plan, THEN the AEGIS Backend SHALL receive a verifiable multi-step RPA tool-use plan
5. WHEN the ADK Agent executes tool calls, THEN the AEGIS Backend SHALL stream the agent's current step and execution status to the WebSocket connection in real-time

### Requirement 2

**User Story:** As a system architect, I want the backend to minimize unnecessary calls to the remote Gemini-based ADK agent, so that the system operates cost-effectively and efficiently.

#### Acceptance Criteria

1. WHEN a task instruction is received, THEN the Pre-Processing Layer SHALL validate the instruction locally before invoking the ADK Agent
2. WHEN the Pre-Processing Layer detects a local issue (e.g., empty instruction, invalid format), THEN the AEGIS Backend SHALL reject the request without calling the ADK Agent
3. WHEN a task instruction is received, THEN the AEGIS Backend SHALL check the Plan Cache for identical or highly similar recent instructions
4. IF a matching cached plan exists, THEN the AEGIS Backend SHALL reuse the cached execution plan instead of requesting a new one from the ADK Agent
5. WHEN defining ADK Tool functions, THEN the AEGIS Backend SHALL design them to be simple and deterministic, requiring remote reasoning only for multi-step planning

### Requirement 3

**User Story:** As a user, I want to submit a natural language task instruction to the backend, so that the system can understand and execute my automation goal.

#### Acceptance Criteria

1. WHEN a user sends a POST request to /api/start_task with a task instruction, THEN the AEGIS Backend SHALL validate the instruction is non-empty and return a unique execution session ID
2. WHEN the AEGIS Backend receives a valid task instruction, THEN the ADK Agent SHALL parse the instruction into a structured sequence of subtasks
3. WHEN the instruction contains multiple goals (e.g., "check email and upload document"), THEN the ADK Agent SHALL identify and sequence all subtasks in logical order
4. WHEN the instruction is ambiguous or cannot be parsed, THEN the AEGIS Backend SHALL return an error response with a clear explanation
5. WHEN the ADK Agent completes parsing, THEN the AEGIS Backend SHALL store the execution session with status "pending"

### Requirement 4

**User Story:** As a system architect, I want the backend to intelligently select interaction strategies, so that the automation can handle both fixed UI elements and dynamic applications.

#### Acceptance Criteria

1. WHEN the Strategy Module analyzes a subtask targeting a desktop icon or fixed UI element, THEN the AEGIS Backend SHALL select the coordinate-based strategy
2. WHEN the Strategy Module analyzes a subtask targeting a web page or dynamic application, THEN the AEGIS Backend SHALL select the element-based strategy
3. WHEN a subtask requires visual identification, THEN the AEGIS Backend SHALL use OCR or image recognition to locate the target element
4. WHEN a subtask requires accessibility-based targeting, THEN the AEGIS Backend SHALL use XPath or accessibility IDs to identify elements
5. WHERE the Strategy Module cannot determine the appropriate strategy, THEN the AEGIS Backend SHALL default to element-based strategy and log a warning

### Requirement 5

**User Story:** As a user, I want the backend to execute desktop actions reliably, so that my automation tasks complete successfully.

#### Acceptance Criteria

1. WHEN the RPA Engine executes a click action, THEN the AEGIS Backend SHALL move the mouse to the target coordinates and perform the click operation
2. WHEN the RPA Engine executes a typing action, THEN the AEGIS Backend SHALL send the specified text as keyboard input to the active window
3. WHEN the RPA Engine executes a key press action, THEN the AEGIS Backend SHALL send the specified key combination (e.g., Ctrl+C) to the system
4. WHEN the RPA Engine executes a drag action, THEN the AEGIS Backend SHALL move the mouse from start coordinates to end coordinates while holding the mouse button
5. WHEN the RPA Engine executes a scroll action, THEN the AEGIS Backend SHALL send scroll events with the specified direction and magnitude

### Requirement 6

**User Story:** As a system architect, I want the backend to observe and verify each action, so that the system can detect failures and adapt accordingly.

#### Acceptance Criteria

1. WHEN the RPA Engine completes an action, THEN the Action Observer SHALL capture the current screen state
2. WHEN the Action Observer analyzes the screen state, THEN the AEGIS Backend SHALL determine if the action succeeded based on expected visual or state changes
3. IF an action fails verification, THEN the AEGIS Backend SHALL retry the action up to three times with exponential backoff
4. IF an action fails after all retries, THEN the AEGIS Backend SHALL mark the execution session as "failed" and report the error
5. WHEN an action succeeds verification, THEN the AEGIS Backend SHALL proceed to the next subtask in the sequence

### Requirement 7

**User Story:** As a frontend developer, I want the backend to provide real-time status updates, so that the UI can display execution progress to the user.

#### Acceptance Criteria

1. WHEN a client establishes a WebSocket connection to /ws/execution/{session_id}, THEN the AEGIS Backend SHALL accept the connection and prepare to stream updates
2. WHEN the RPA Engine starts a subtask, THEN the AEGIS Backend SHALL send a status update containing the subtask description and status "in_progress"
3. WHEN the RPA Engine completes a subtask, THEN the AEGIS Backend SHALL send a status update containing the subtask description and status "completed"
4. IF a subtask fails, THEN the AEGIS Backend SHALL send a status update containing the error message and status "failed"
5. WHEN the execution session completes, THEN the AEGIS Backend SHALL send a final status update with overall session status and close the WebSocket connection

### Requirement 8

**User Story:** As a user, I want the backend to handle errors gracefully, so that I understand what went wrong when automation fails.

#### Acceptance Criteria

1. WHEN the RPA Engine encounters a system-level error (e.g., permission denied), THEN the AEGIS Backend SHALL capture the error details and return a structured error response
2. WHEN an application fails to launch, THEN the AEGIS Backend SHALL detect the failure within 10 seconds and report it to the client
3. WHEN a target UI element cannot be found, THEN the AEGIS Backend SHALL report the missing element with context about what was being searched
4. WHEN the system is under high load, THEN the AEGIS Backend SHALL queue incoming task requests and process them sequentially
5. WHEN an execution session is interrupted (e.g., user cancellation), THEN the AEGIS Backend SHALL clean up resources and mark the session as "cancelled"

### Requirement 9

**User Story:** As a system architect, I want the backend to expose a well-typed REST API, so that the frontend can reliably communicate with the automation engine.

#### Acceptance Criteria

1. WHEN defining API endpoints, THEN the AEGIS Backend SHALL use Pydantic models for all request and response bodies
2. WHEN a client sends a malformed request, THEN the AEGIS Backend SHALL return a 422 status code with validation error details
3. WHEN the API receives a request, THEN the AEGIS Backend SHALL validate all required fields are present and correctly typed
4. WHEN the API returns a response, THEN the AEGIS Backend SHALL include appropriate HTTP status codes (200, 400, 422, 500)
5. WHEN the server starts, THEN the AEGIS Backend SHALL expose OpenAPI documentation at /docs

### Requirement 10

**User Story:** As a developer, I want the backend to maintain execution history, so that users can review past automation sessions.

#### Acceptance Criteria

1. WHEN an execution session starts, THEN the AEGIS Backend SHALL create a session record with timestamp, instruction, and initial status
2. WHEN subtasks are executed, THEN the AEGIS Backend SHALL append each subtask result to the session record
3. WHEN a client requests GET /api/history, THEN the AEGIS Backend SHALL return a list of all execution sessions ordered by timestamp descending
4. WHEN a client requests GET /api/history/{session_id}, THEN the AEGIS Backend SHALL return the complete details of the specified session
5. WHEN the session record is stored, THEN the AEGIS Backend SHALL persist it to disk or database for retrieval after server restart

### Requirement 11

**User Story:** As a system architect, I want the backend to support multi-app orchestration, so that complex workflows spanning multiple applications can be automated.

#### Acceptance Criteria

1. WHEN a task instruction involves multiple applications (e.g., "check Outlook and upload to Chrome"), THEN the AEGIS Backend SHALL identify all required applications
2. WHEN switching between applications, THEN the AEGIS Backend SHALL bring the target application to focus before executing actions
3. WHEN an application is not running, THEN the AEGIS Backend SHALL launch the application and wait for it to be ready
4. WHEN data must be transferred between applications (e.g., copy from Excel to Word), THEN the AEGIS Backend SHALL use clipboard operations or file-based transfer
5. WHEN orchestrating multiple applications, THEN the AEGIS Backend SHALL maintain context about which application is currently active

### Requirement 12

**User Story:** As a user, I want the backend to handle text input intelligently, so that typing actions work reliably across different applications.

#### Acceptance Criteria

1. WHEN typing text into an input field, THEN the AEGIS Backend SHALL ensure the target field has focus before sending keystrokes
2. WHEN typing special characters, THEN the AEGIS Backend SHALL properly encode and send the characters using the correct key combinations
3. WHEN typing into a web form, THEN the AEGIS Backend SHALL simulate human-like typing speed to avoid triggering anti-bot measures
4. WHEN clearing existing text, THEN the AEGIS Backend SHALL select all text (Ctrl+A) and delete it before typing new content
5. WHEN typing is complete, THEN the AEGIS Backend SHALL verify the text appears in the target field

### Requirement 13

**User Story:** As a system architect, I want the backend to control the frontend window state during execution, so that the RPA agent has unobstructed access to the desktop and other applications.

#### Acceptance Criteria

1. WHEN the ADK Agent begins a subtask that requires desktop access (click, type, image recognition), THEN the AEGIS Backend SHALL send a 'WINDOW_STATE_MINIMAL' command via WebSocket
2. WHEN the 'WINDOW_STATE_MINIMAL' command is sent, THEN the AEGIS Backend SHALL include it in the status update message structure
3. WHEN the execution session completes (success or failure), THEN the AEGIS Backend SHALL send a 'WINDOW_STATE_NORMAL' command via WebSocket
4. WHEN the user cancels an execution, THEN the AEGIS Backend SHALL send a 'WINDOW_STATE_NORMAL' command to restore the window
5. WHEN sending window state commands, THEN the AEGIS Backend SHALL ensure they are sent before the corresponding subtask execution begins
